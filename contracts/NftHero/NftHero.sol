// SPDX-License-Identifier: MIT
pragma solidity ^0.8.6;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract NftHero is
  AccessControlEnumerable,
  ERC721Enumerable,
  ERC721Burnable,
  ERC721Pausable
{
  using Strings for uint256;
  using SafeMath for uint256;

  // Mapping token id to unit level
  mapping(uint256 => uint256) internal _level;

  // Mapping token id to unit race
  mapping(uint256 => uint256) internal _race;

  // Mapping token id to unit gender
  mapping(uint256 => uint256) internal _gender;

  // Mapping token id to unit faction
  mapping(uint256 => uint256) internal _faction;

  // Mapping token id to unit name
  mapping(uint256 => string) internal _name;

  // Mapping token id to unit name
  mapping(uint256 => uint256) internal _score;
  
  struct HeroData {
    uint256 tokenId;
    uint256 level;
    uint256 race;
    uint256 gender;
    uint256 faction;
    string name;
    bytes bname;
    string uri;
  }

  uint256 _txFeeAmount = 0;
  address _feeToken;
  address _feeRecipient;

  using Counters for Counters.Counter;

  bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
  bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
  bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
  bytes32 public constant LEVEL_INCREMENTER_ROLE = keccak256("LEVEL_INCREMENTER_ROLE");
  bytes32 public constant SCORE_EDITOR_ROLE = keccak256("SCORE_EDITOR_ROLE");

  Counters.Counter private _tokenIdTracker;

  string private _baseTokenURI;

  /**
    * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE`, `PAUSER_ROLE`, `ADMIN_ROLE`,
    * `LEVEL_INCREMENTER_ROLE`, `SCORE_EDITOR_ROLE` to the account that deploys
    * the contract.
    *
    * Token URIs will be autogenerated based on `baseURI` and their token props.
    * See {ERC721-tokenURI}.
    */
  constructor(
    string memory name,
    string memory symbol,
    string memory baseTokenURI
  ) ERC721(name, symbol) {
    _baseTokenURI = baseTokenURI;
    _feeRecipient = _msgSender();

    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

    _setupRole(MINTER_ROLE, _msgSender());
    _setupRole(PAUSER_ROLE, _msgSender());
    _setupRole(ADMIN_ROLE, _msgSender());
    _setupRole(LEVEL_INCREMENTER_ROLE, _msgSender());
    _setupRole(SCORE_EDITOR_ROLE, _msgSender());
  }

  function _baseURI() internal view virtual override returns (string memory) {
    return _baseTokenURI;
  }

  /**
    * @dev If set, the resulting URI for each token will be the concatenation of the `baseURI` and
    * `_race[tokenId]/_faction[tokenId]/_gender[tokenId]/_level[tokenId]`.
    *
    * Requirements:
    *
    * - the caller must have the `ADMIN_ROLE`.
    */
  function setBaseUrl(string memory newBaseUrl) public {
    require(hasRole(ADMIN_ROLE, _msgSender()), "NftUnit: must have admin role to change bas URI");

    _baseTokenURI = newBaseUrl;
  }

  /**
    * @dev Pauses all token transfers.
    *
    * See {ERC721Pausable} and {Pausable-_pause}.
    *
    * Requirements:
    *
    * - the caller must have the `PAUSER_ROLE`.
    */
  function pause() public virtual {
      require(hasRole(PAUSER_ROLE, _msgSender()), "NftUnit: must have pauser role to pause");
      _pause();
  }

  /**
    * @dev Unpauses all token transfers.
    *
    * See {ERC721Pausable} and {Pausable-_unpause}.
    *
    * Requirements:
    *
    * - the caller must have the `PAUSER_ROLE`.
    */
  function unpause() public virtual {
      require(hasRole(PAUSER_ROLE, _msgSender()), "NftUnit: must have pauser role to unpause");
      _unpause();
  }

  function _beforeTokenTransfer(
      address from,
      address to,
      uint256 tokenId
  ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {
      super._beforeTokenTransfer(from, to, tokenId);
  }

  /**
    * @dev See {IERC165-supportsInterface}.
    */
  function supportsInterface(bytes4 interfaceId)
      public
      view
      virtual
      override(AccessControlEnumerable, ERC721, ERC721Enumerable)
      returns (bool)
  {
      return super.supportsInterface(interfaceId);
  }

  /**
   * @dev See {IERC721Metadata-tokenURI}.
   */
  function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
    require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");

    string memory baseURI = _baseURI();
    return bytes(baseURI).length > 0 ? string(
      abi.encodePacked(
        baseURI,
        _race[tokenId].toString(), '/',
        _faction[tokenId].toString(), '/',
        _gender[tokenId].toString(), '/',
        _level[tokenId].toString()
      )
    ) : "";
  }

  /**
    * @dev Creates a new token for `to`. Its token ID will be automatically
    * assigned (and available on the emitted {IERC721-Transfer} event), and the token
    * URI autogenerated based on the base URI passed at construction.
    *
    * See {ERC721-_mint}.
    *
    * Requirements:
    *
    * - the caller must have the `MINTER_ROLE`.
    */
  function createHero(
    address to,
    uint256 level,
    uint256 score,
    uint256 race,
    uint256 gender,
    uint256 faction,
    string memory name
  ) public returns(uint256 tokenId) {
    require(hasRole(MINTER_ROLE, _msgSender()), "NftUnit: must have minter role to mint");

    // Validate hero name
    bytes memory bName = bytes(name);
    require(bName.length < 13 && bName.length > 3, "NftUnit: invalid heros name");

    for(uint i = 0; i < bName.length; i++){
      bytes1 char = bName[i];

      require(char >= 0x61 && char <= 0x7A /* a-z */, "NftUnit: invalid heros name");
    }
  
    // We cannot just use balanceOf to create the new tokenId because tokens
    // can be burned (destroyed), so we need a separate counter.
    tokenId = _tokenIdTracker.current();

    _mint(to, tokenId);
    _tokenIdTracker.increment();

    _level[tokenId] = level;
    _score[tokenId] = score;
    _race[tokenId] = race;
    _gender[tokenId] = gender;
    _faction[tokenId] = faction;
    _name[tokenId] = name;
  }

  function transfer(
    address to,
    uint256 tokenId
  ) public {
    _transfer(_msgSender(), to, tokenId);
  }

  function safeTransfer(
    address to,
    uint256 tokenId,
    bytes memory _data
  ) public {
    _safeTransfer(_msgSender(), to, tokenId, _data);
  }

  function getHero(uint256 _tokenId) public view returns(
    uint256 tokenId,
    uint256 level,
    uint256 race,
    uint256 gender,
    uint256 faction,
    string memory name,
    string memory uri
  ) {
    require(_exists(_tokenId), "NftUnit: data query for nonexistent token");

    return (
      _tokenId,
      _level[_tokenId],
      _race[_tokenId],
      _gender[_tokenId],
      _faction[_tokenId],
      _name[_tokenId],
      tokenURI(_tokenId)
    );
  }

  function getLevel(uint256 tokenId) public view returns(uint256) {
    return _level[tokenId];
  }

  /**
    * Requirements:
    *
    * - the caller must have the `LEVEL_INCREMENTER_ROLE`.
    */
  function incrementLevel(uint256 tokenId) public {
    require(hasRole(LEVEL_INCREMENTER_ROLE, _msgSender()), "NftUnit: must have level incrementer role to increment level");

    _level[tokenId] += 1;
  }

  function getScore(uint256 tokenId) public view returns(uint256) {
    return _score[tokenId];
  }

  function scorePlus(uint256 tokenId, uint256 value) public returns(bool) {
    require(hasRole(SCORE_EDITOR_ROLE, _msgSender()), "NftUnit: must have level incrementer role to increment level");

    (bool isSuccess, uint256 newScore) = _score[tokenId].tryAdd(value);
  
    _score[tokenId] = newScore;

    return isSuccess;
  }

  function scoreMinus(uint256 tokenId, uint256 value) public returns(bool) {
    require(hasRole(SCORE_EDITOR_ROLE, _msgSender()), "NftUnit: must have level incrementer role to increment level");

    (bool isSuccess, uint256 newScore) = _score[tokenId].trySub(value);
  
    _score[tokenId] = newScore;

    return isSuccess;
  }

  /**
    * Requirements:
    *
    * - the caller must have the `ADMIN_ROLE`.
    */
  function setTxFeeAmount(uint256 amount) public {
    require(hasRole(ADMIN_ROLE, _msgSender()), "NftUnit: must have admin role to set fee amount");

    _txFeeAmount = amount;
  }

  function txFeeAmount() public view returns(uint256) {
    return _txFeeAmount;
  }

  /**
    * Requirements:
    *
    * - the caller must have the `ADMIN_ROLE`.
    */
  function setFeeToken(address tokenAddress) public {
    require(hasRole(ADMIN_ROLE, _msgSender()), "NftUnit: must have admin role to set fee token");

    _feeToken = tokenAddress;
  }

  function feeToken() public view returns(address) {
    return _feeToken;
  }

  /**
    * Requirements:
    *
    * - the caller must have the `ADMIN_ROLE`.
    */
  function setFeeRecipient(address feeRecipientAddress) public {
    require(hasRole(ADMIN_ROLE, _msgSender()), "NftUnit: must have admin role to set fee recipient");

    _feeRecipient = feeRecipientAddress;
  }

  function feeRecipient() public view returns(address) {
    return _feeRecipient;
  }

  function _payTxFee(address from) internal {
    if (_txFeeAmount > 0 && _feeToken != address(0) && _feeRecipient != address(0)) {
      ERC20 token = ERC20(_feeToken);
      token.transferFrom(from, _feeRecipient, _txFeeAmount);
    }
  }
}
