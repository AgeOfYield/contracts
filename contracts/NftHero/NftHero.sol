// SPDX-License-Identifier: MIT
pragma solidity ^0.8.6;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "./abstract/HeroCharacteristics.sol";

contract NftHero is
  AccessControlEnumerable,
  ERC721Enumerable,
  ERC721Burnable,
  ERC721Pausable,
  HeroCharacteristics
{
  using Strings for uint256;
  using SafeMath for uint256;
  
  struct HeroData {
    uint256 tokenId;
    uint256 level;
    uint256 race;
    uint256 gender;
    uint256 faction;
    string name;
    bytes bname;
    string uri;
  }

  // Mapping token id to hero race
  mapping(uint256 => uint256) internal _race;

  // Mapping token id to hero gender
  mapping(uint256 => uint256) internal _gender;

  // Mapping token id to hero faction
  mapping(uint256 => uint256) internal _faction;

  // Mapping token id to hero name
  mapping(uint256 => string) internal _name;

  using Counters for Counters.Counter;

  bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
  bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
  bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
  bytes32 public constant LEVEL_INCREMENTER_ROLE = keccak256("LEVEL_INCREMENTER_ROLE");
  bytes32 public constant SCORE_EDITOR_ROLE = keccak256("SCORE_EDITOR_ROLE");
  bytes32 public constant VIEWER_OF_CHARACTERISTICS = keccak256("VIEWER_OF_CHARACTERISTICS");

  Counters.Counter private _tokenIdTracker;

  string private _baseTokenURI;

  /**
    * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE`, `PAUSER_ROLE`, `ADMIN_ROLE`,
    * `LEVEL_INCREMENTER_ROLE`, `SCORE_EDITOR_ROLE` to the account that deploys
    * the contract.
    *
    * Token URIs will be autogenerated based on `baseURI` and their token props.
    * See {ERC721-tokenURI}.
    */
  constructor(
    string memory name,
    string memory symbol,
    string memory baseTokenURI
  ) ERC721(name, symbol) {
    _baseTokenURI = baseTokenURI;

    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

    _setupRole(MINTER_ROLE, _msgSender());
    _setupRole(PAUSER_ROLE, _msgSender());
    _setupRole(ADMIN_ROLE, _msgSender());
    _setupRole(LEVEL_INCREMENTER_ROLE, _msgSender());
    _setupRole(SCORE_EDITOR_ROLE, _msgSender());
    _setupRole(VIEWER_OF_CHARACTERISTICS, _msgSender());

    _pause();
  }

  function _baseURI() internal view virtual override returns (string memory) {
    return _baseTokenURI;
  }

  /**
    * @dev If set, the resulting URI for each token will be the concatenation of the `baseURI` and
    * `_race[tokenId]/_faction[tokenId]/_gender[tokenId]/_level[tokenId]`.
    *
    * Requirements:
    *
    * - the caller must have the `ADMIN_ROLE`.
    */
  function setBaseUrl(string memory newBaseUrl) public {
    require(hasRole(ADMIN_ROLE, _msgSender()), "NftHero: must have admin role to change bas URI");

    _baseTokenURI = newBaseUrl;
  }

  /**
    * @dev Pauses all token transfers.
    *
    * See {ERC721Pausable} and {Pausable-_pause}.
    *
    * Requirements:
    *
    * - the caller must have the `PAUSER_ROLE`.
    */
  function pause() public virtual {
      require(hasRole(PAUSER_ROLE, _msgSender()), "NftHero: must have pauser role to pause");
      _pause();
  }

  /**
    * @dev Unpauses all token transfers.
    *
    * See {ERC721Pausable} and {Pausable-_unpause}.
    *
    * Requirements:
    *
    * - the caller must have the `PAUSER_ROLE`.
    */
  function unpause() public virtual {
      require(hasRole(PAUSER_ROLE, _msgSender()), "NftHero: must have pauser role to unpause");
      _unpause();
  }

  function _beforeTokenTransfer(
      address from,
      address to,
      uint256 tokenId
  ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {
      super._beforeTokenTransfer(from, to, tokenId);
  }

  /**
    * @dev See {IERC165-supportsInterface}.
    */
  function supportsInterface(bytes4 interfaceId)
      public
      view
      virtual
      override(AccessControlEnumerable, ERC721, ERC721Enumerable)
      returns (bool)
  {
      return super.supportsInterface(interfaceId);
  }

  /**
   * @dev See {IERC721Metadata-tokenURI}.
   */
  function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
    require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");

    string memory baseURI = _baseURI();
    return bytes(baseURI).length > 0 ? string(
      abi.encodePacked(
        baseURI,
        _race[tokenId].toString(), '/',
        _faction[tokenId].toString(), '/',
        _gender[tokenId].toString(), '/',
        _level[tokenId].toString()
      )
    ) : "";
  }

  /**
    * @dev Creates a new token for `to`. Its token ID will be automatically
    * assigned (and available on the emitted {IERC721-Transfer} event), and the token
    * URI autogenerated based on the base URI passed at construction.
    *
    * See {ERC721-_mint}.
    *
    * Requirements:
    *
    * - the caller must have the `MINTER_ROLE`.
    */
  function createHero(
    address to,
    uint256 level,
    uint256 score,
    uint256 race,
    uint256 gender,
    uint256 faction,
    string memory name,
    Characteristics memory characteristics
  ) public whenNotPaused returns(uint256 tokenId) {
    require(hasRole(MINTER_ROLE, _msgSender()), "NftHero: must have minter role to mint");

    // Validate hero name
    bytes memory bName = bytes(name);
    require(bName.length < 13 && bName.length > 3, "NftHero: invalid name of hero");

    for(uint i = 0; i < bName.length; i++){
      bytes1 char = bName[i];

      require(char >= 0x61 && char <= 0x7A /* a-z */, "NftHero: invalid name of hero");
    }
  
    // We cannot just use balanceOf to create the new tokenId because tokens
    // can be burned (destroyed), so we need a separate counter.
    tokenId = _tokenIdTracker.current();

    _mint(to, tokenId);
    _tokenIdTracker.increment();

    _level[tokenId] = level;
    _score[tokenId] = score;
    _race[tokenId] = race;
    _gender[tokenId] = gender;
    _faction[tokenId] = faction;
    _name[tokenId] = name;
    _characteristics[tokenId] = characteristics;
  }

  function transfer(address to, uint256 tokenId) public {
    _transfer(_msgSender(), to, tokenId);
  }

  function safeTransfer(address to, uint256 tokenId, bytes memory _data) public {
    _safeTransfer(_msgSender(), to, tokenId, _data);
  }

  function getHero(uint256 _tokenId) public view returns(
    uint256 tokenId,
    uint256 level,
    uint256 score,
    uint256 race,
    uint256 gender,
    uint256 faction,
    string memory name,
    string memory uri
  ) {
    require(_exists(_tokenId), "NftHero: data query for nonexistent token");

    tokenId = _tokenId;
    level = _level[_tokenId];
    score = _score[_tokenId];
    race = _race[_tokenId];
    gender = _gender[_tokenId];
    faction = _faction[_tokenId];
    name = _name[_tokenId];
    uri = tokenURI(_tokenId);

    return (
      tokenId,
      level,
      score,
      race,
      gender,
      faction,
      name,
      uri
    );
  }

  function getScore(uint256 tokenId) public view override returns(uint256) {
    require(hasRole(VIEWER_OF_CHARACTERISTICS, _msgSender()), "NftHero: must have viewer of characteristics role to get attack");

    return super.getScore(tokenId);
  }

  /**
    * Requirements:
    *
    * - the caller must have the `VIEWER_OF_CHARACTERISTICS`.
    */
  function getAttack(uint256 tokenId) public view override returns(uint256) {
    require(hasRole(VIEWER_OF_CHARACTERISTICS, _msgSender()), "NftHero: must have viewer of characteristics role to get attack");

    return super.getAttack(tokenId);
  }

  /**
    * Requirements:
    *
    * - the caller must have the `VIEWER_OF_CHARACTERISTICS`.
    */
  function getDefense(uint256 tokenId) public view override returns(uint256) {
    require(hasRole(VIEWER_OF_CHARACTERISTICS, _msgSender()), "NftHero: must have viewer of characteristics role to get defense");

    return super.getDefense(tokenId);
  }

  /**
    * Requirements:
    *
    * - the caller must have the `VIEWER_OF_CHARACTERISTICS`.
    */
  function getMining(uint256 tokenId) public view override returns(uint256) {
    require(hasRole(VIEWER_OF_CHARACTERISTICS, _msgSender()), "NftHero: must have viewer of characteristics role to get mining");

    return super.getMining(tokenId);
  }

  /**
    * Requirements:
    *
    * - the caller must have the `VIEWER_OF_CHARACTERISTICS`.
    */
  function getCapacity(uint256 tokenId) public view override returns(uint256) {
    require(hasRole(VIEWER_OF_CHARACTERISTICS, _msgSender()), "NftHero: must have viewer of characteristics role to get capacity");

    return super.getCapacity(tokenId);
  }

  /**
    * Requirements:
    *
    * - the caller must have the `VIEWER_OF_CHARACTERISTICS`.
    */
  function getStamina(uint256 tokenId) public view override returns(uint256) {
    require(hasRole(VIEWER_OF_CHARACTERISTICS, _msgSender()), "NftHero: must have viewer of characteristics role to get stamina");

    return super.getStamina(tokenId);
  }

  /**
    * Requirements:
    *
    * - the caller must have the `VIEWER_OF_CHARACTERISTICS`.
    */
  function getFortune(uint256 tokenId) public view override returns(uint256) {
    require(hasRole(VIEWER_OF_CHARACTERISTICS, _msgSender()), "NftHero: must have viewer of characteristics role to get fortune");

    return super.getFortune(tokenId);
  }

  /**
    * Requirements:
    *
    * - the caller must have the `VIEWER_OF_CHARACTERISTICS`.
    */
  function getCharacteristics(uint256 tokenId) public view override returns(Characteristics memory) {
    require(
      (hasRole(VIEWER_OF_CHARACTERISTICS, _msgSender()) || ownerOf(tokenId) == _msgSender()),
      "NftHero: must have viewer of characteristics role or be owner to get characteristics"
    );

    return super.getCharacteristics(tokenId);
  }

  /**
    * Requirements:
    *
    * - the caller must have the `LEVEL_INCREMENTER_ROLE`.
    */
  function levelUp(uint256 tokenId, uint16[] memory characteristics) public override whenNotPaused {
    require(hasRole(LEVEL_INCREMENTER_ROLE, _msgSender()), "NftHero: must have level incrementer role to increment level");

    super.levelUp(tokenId, characteristics);
  }

  /**
    * Requirements:
    *
    * - the caller must have the `SCORE_EDITOR_ROLE`.
    */
  function addScore(uint256 tokenId, uint256 value) public override whenNotPaused {
    require(hasRole(SCORE_EDITOR_ROLE, _msgSender()), "NftHero: must have score editor role to change score");

    super.addScore(tokenId, value);
  }

  /**
    * Requirements:
    *
    * - the caller must have the `SCORE_EDITOR_ROLE`.
    */
  function subScore(uint256 tokenId, uint256 value) public override whenNotPaused {
    require(hasRole(SCORE_EDITOR_ROLE, _msgSender()), "NftHero: must have score editor role to change score");

    super.subScore(tokenId, value);
  }

  /**
    * Requirements:
    *
    * - the caller must have the `ADMIN_ROLE`.
    */
  function setSkillPoints(uint16 maxSkillPoints) public override {
    require(hasRole(ADMIN_ROLE, _msgSender()), "NftHero: must have admin role to set max skill points");

    super.setSkillPoints(maxSkillPoints);
  }

  /**
    * Requirements:
    *
    * - the caller must have the `ADMIN_ROLE`.
    */
  function setMultiplierOfCharacteristics(uint256 factorC) public override {
    require(hasRole(ADMIN_ROLE, _msgSender()), "NftHero: must have admin role to set multiplier of characteristics");

    super.setMultiplierOfCharacteristics(factorC);
  }

  /**
    * Requirements:
    *
    * - the caller must have the `ADMIN_ROLE`.
    */
  function setScoreFactorA(uint256 factorA) public override {
    require(hasRole(ADMIN_ROLE, _msgSender()), "NftHero: must have admin role to set factor A for score");

    super.setScoreFactorA(factorA);
  }

  /**
    * Requirements:
    *
    * - the caller must have the `ADMIN_ROLE`.
    */
  function setScoreFactorC(uint256 factorC) public override {
    require(hasRole(ADMIN_ROLE, _msgSender()), "NftHero: must have admin role to set factor C for score");

    super.setScoreFactorC(factorC);
  }
}
